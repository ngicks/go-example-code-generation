package main

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"io/fs"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"slices"
	"strconv"
	"strings"
	"text/template"
	"unicode"
)

var funcs = template.FuncMap{
	"capitalize": func(s string) string {
		if len(s) == 0 {
			return s
		}
		if len(s) == 1 {
			return strings.ToUpper(s)
		}
		return strings.ToUpper(s[:1]) + s[1:]
	},
	"replaceInvalidChar": func(s string) string {
		// As per Go programming specification.
		// identifier = letter { letter | unicode_digit }.
		// https://go.dev/ref/spec#Identifiers
		return strings.Map(func(r rune) rune {
			if unicode.IsLetter(r) || r == '_' || unicode.IsDigit(r) {
				return r
			}
			return '_'
		}, s)
	},
	"quote": func(s string) string {
		return strconv.Quote(s)
	},
}

var pkg = template.Must(template.New("pkg").
	Funcs(funcs).
	Parse(
		`// Code generated by me. DO NOT EDIT.
package {{.PackageName}}

import (
{{range .Imports}}	{{if .Qual}}{{.Qual}} {{end}}{{quote .PkgPath}}
{{end -}}
)

var bufPool = &sync.Pool{
	New: func() any {
		return new(bytes.Buffer)
	},
}

func getBuf() *bytes.Buffer {
	return bufPool.Get().(*bytes.Buffer)
}

func putBuf(b *bytes.Buffer) {
	if b == nil || b.Cap() > 64<<10 {
		return
	}
	b.Reset()
	bufPool.Put(b)
}

{{block "user-input" .UserTemplateArg}}{{end}}
`))

type UserInput struct {
	// package name of generated code.
	PackageName string
	// Imports describes dependencies to other packages to which the Template text depends.
	// Template will not use packages other than described in this field.
	// Template may use all, some of, or even none of imported packages in the generated code.
	//
	// Imports maps the import path (key) to the template arg name (value).
	// Template refers to import qualifiers by template arg name(value) and
	// it expects values are provided under Imports key,
	// e.g. Template may describe imports by map[string]string{"bytes": "Bytes"} and refer to it as {{.Imports.Bytes}}.
	//
	// The values are also allowed to be `.` or `_`.
	// In those cases, the generated code will have dot or underscore imports
	// and Template will not receive those values.
	Imports map[string]string
	// template text
	Template string
}

type TemplateParam struct {
	PackageName     string
	Imports         []ImportSpec
	UserTemplateArg UserTemplateArg
}

type ImportSpec struct {
	// Qual is the import qualifier name. Maybe empty.
	// If empty, the qual must be lexically inferred from PkgPath.
	Qual    string
	PkgPath string
}

type UserTemplateArg struct {
	// Imports maps arg name to package qualifier.
	Imports map[string]string
}

func main() {
	err := checkGoimports()
	if err != nil {
		panic(err)
	}

	targetDir := filepath.Join("template", "handle-imports", "target")
	err = os.Mkdir(targetDir, fs.ModePerm)
	if err != nil && !errors.Is(err, fs.ErrExist) {
		panic(err)
	}

	userInput := UserInput{
		PackageName: "main",
		Imports: map[string]string{
			"bytes":         "Bytes",
			"crypto":        "Crypto",
			"crypto/rand":   "CryptoRand",
			"crypto/sha256": "_",
			"crypto/sha512": "_",
			"encoding/hex":  "Hex",
			"fmt":           ".",
			"io":            "Io",
			"math/rand/v2":  "MathRand",
		},
		Template: `func main() {
	randBuf := getBuf()
	defer putBuf(randBuf)

	var err error

	_, err = {{.Imports.Io}}.CopyN(randBuf, {{.Imports.CryptoRand}}.Reader, 16)
	if err != nil {
		panic(err)
	}
	for i := 0; i < 16; i++ {
		_ = randBuf.WriteByte({{.Imports.MathRand}}.N(byte(255)))
	}

	_, _ = Printf("rand bytes=%q\n", {{.Imports.Hex}}.EncodeToString(randBuf.Bytes()))

	h := {{.Imports.Crypto}}.SHA256.New()
	_, err = {{.Imports.Io}}.Copy(h, {{.Imports.Bytes}}.NewReader(randBuf.Bytes()))
	if err != nil {
		panic(err)
	}
	_, _ = Printf("sha256sum=%q\n", {{.Imports.Hex}}.EncodeToString(h.Sum(nil)))

	h = {{.Imports.Crypto}}.SHA512.New()
	_, err = {{.Imports.Io}}.Copy(h, {{.Imports.Bytes}}.NewReader(randBuf.Bytes()))
	if err != nil {
		panic(err)
	}
	_, _ = Printf("sha512sum=%q\n", {{.Imports.Hex}}.EncodeToString(h.Sum(nil)))
}
`,
	}

	_, err = pkg.New("user-input").Parse(userInput.Template)
	if err != nil {
		panic(err)
	}

	var buf bytes.Buffer
	specs := makeImportSpecs([]ImportSpec{{"", "bytes"}, {"", "sync"}}, userInput.Imports)
	err = pkg.Execute(&buf, TemplateParam{
		PackageName: userInput.PackageName,
		Imports:     specs,
		UserTemplateArg: UserTemplateArg{
			Imports: makeUserImportArg(specs, userInput.Imports),
		},
	})
	if err != nil {
		panic(err)
	}

	formatted, err := applyGoimports(context.Background(), &buf)
	if err != nil {
		panic(err)
	}

	targetFile := filepath.Join(targetDir, "main.go")
	f, err := os.Create(targetFile)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	_, err = io.Copy(f, formatted)
	if err != nil {
		panic(err)
	}
}

func qualFromPkgPath(pkgPath string) string {
	base := path.Base(pkgPath)
	if base == pkgPath {
		// contains no `/`
		return pkgPath
	}
	majorVersion, has := strings.CutPrefix(base, "v")
	if !has {
		// no major version.
		return base
	}
	if len(strings.TrimLeftFunc(majorVersion, func(r rune) bool {
		return '0' <= r && r <= '9'
	})) == 0 {
		// suffix is major version
		return path.Base(path.Dir(pkgPath))
	}
	return base
}

func makeImportSpecs(preDeclared []ImportSpec, userImports map[string]string) []ImportSpec {
	importSpecs := slices.Clone(preDeclared)

	// maps qualifier name to package path.
	qualToPkgPath := make(map[string]string, len(importSpecs)+len(userImports))

	for _, spec := range importSpecs {
		if spec.Qual == "." || spec.Qual == "_" {
			continue
		}
		name := spec.Qual
		if name == "" {
			name = qualFromPkgPath(spec.PkgPath)
		}
		qualToPkgPath[name] = spec.PkgPath
	}

	userPackagePaths := make([]string, 0, len(userImports))
	for k := range userImports {
		userPackagePaths = append(userPackagePaths, k)
	}
	slices.Sort(userPackagePaths)
USER_PKG:
	for _, pkgPath := range userPackagePaths {
		arg := userImports[pkgPath]
		switch arg {
		case ".", "_":
			importSpecs = append(importSpecs, ImportSpec{arg, pkgPath})
		default:
			name := qualFromPkgPath(pkgPath)
			org := name
			fallenBack := false
			for i := 0; ; i++ {
				knownPkgPath, has := qualToPkgPath[name]
				if knownPkgPath == pkgPath {
					continue USER_PKG
				}
				if !has {
					qualToPkgPath[name] = pkgPath
					break
				}
				fallenBack = true
				name = org + "_" + strconv.FormatInt(int64(i), 10)
			}
			if !fallenBack {
				name = ""
			}
			importSpecs = append(importSpecs, ImportSpec{name, pkgPath})
		}
	}

	slices.SortFunc(importSpecs, func(i, j ImportSpec) int {
		if c := strings.Compare(i.PkgPath, j.PkgPath); c != 0 {
			return c
		}
		return strings.Compare(i.Qual, j.Qual)
	})

	importSpecs = slices.CompactFunc(importSpecs, func(i, j ImportSpec) bool {
		return i.Qual == j.Qual && i.PkgPath == j.PkgPath
	})

	return importSpecs
}

func makeUserImportArg(specs []ImportSpec, userImports map[string]string) map[string]string {
	pkgNames := make(map[string][]string)
	for _, spec := range specs {
		if spec.Qual == "." || spec.Qual == "_" {
			continue
		}
		name := spec.Qual
		if name == "" {
			name = qualFromPkgPath(spec.PkgPath)
		}
		pkgNames[spec.PkgPath] = append(pkgNames[spec.PkgPath], name)
	}

	userImportArg := make(map[string]string)
	for pkgPath, arg := range userImports {
		if arg == "." || arg == "_" {
			continue
		}
		userImportArg[arg] = pkgNames[pkgPath][0]
	}

	return userImportArg
}

func checkGoimports() error {
	_, err := exec.LookPath("goimports")
	return err
}

func applyGoimports(ctx context.Context, r io.Reader) (*bytes.Buffer, error) {
	cmd := exec.CommandContext(ctx, "goimports")
	cmd.Stdin = r
	formatted := new(bytes.Buffer)
	stderr := new(bytes.Buffer)
	cmd.Stdout = formatted
	cmd.Stderr = stderr
	err := cmd.Run()
	if err != nil {
		return nil, fmt.Errorf("goimports failed: err = %v, msg = %s", err, stderr.Bytes())
	}
	return formatted, nil
}
